"""
This module contains some basic permutation group algorithms, for:

-computing orbits and transversals, 
-computing generators for a stabilizer, and
-reducing a generating set to an equivalent one of at most quadratic size.

Most important functions:

 Orbit		(computes orbit and transversal)
 Stabilizer	(computes generators for a stabilizer subgroup)

Use this with permutation objects generated by the module permv2.py
(Or your own permutation objects that support equivalent methods).
"""

# basicpermutationgroup.py: based on fir/perm/basicpermutationgroup
#	uses permv2, reversed composition.
# 18-03-2015, Paul Bonsma


from permv2 import Permutation


def compute_orbit(generators: [Permutation], element: int, return_transversal=False):
    """
    This function computes the orbit 'orbit' of 'element' in group H.

    If 'return_transversal' = True, it also returns a transversal 'U'
    For every index i, U[i] is a permutation from H that maps <el> to orbit[i].

    :param generators: list of permutations (from permv2.py), represent a generating set of a permutation group H
    :param element: element of the ground set (which should be from 0...n-1)
    :param return_transversal: returns a traversal <U> if True
    :return: A 2-tuple (orbit,U), where U: traversal
    """
    orbit = [element]
    if len(generators) == 0:
        return orbit, None
    n = generators[0].n
    memberVec = [0] * n
    memberVec[element] = 1
    if return_transversal:
        U = [Permutation(n)]
    ind = 0
    while ind < len(orbit):
        element = orbit[ind]
        for P in generators:
            mapped_element = P[element]
            if not memberVec[mapped_element]:
                memberVec[mapped_element] = 1
                orbit.append(mapped_element)
                if return_transversal:
                    U.append(P * U[ind])
        ind += 1
    for element in orbit:
        memberVec[element] = 0
    if return_transversal:
        return orbit, U
    else:
        return orbit


def schreier_generators(generators: [Permutation], element: int) -> [Permutation]:
    """
    Returns a number of permutations that are in the <element>-stabilizer subgroup
    of H, which is in fact a generating set for this stabilizer subgroup.
    This may be a long list, which may even contain duplicates.

    :param generators: list of permutations that generate a group H
    :param element: element from the ground set 0...n-1
    :return: list of permutations that are in the <element>-stabilizer subgroup of H
    """
    O, U = compute_orbit(generators, element, True)
    SchrGen = []
    for ind in range(len(O)):
        element = O[ind]
        for P in generators:
            mapel = O.index(P[element])
            newgen = -U[mapel] * P * U[ind]
            if not newgen.istrivial():
                SchrGen.append(newgen)
    return SchrGen


def find_non_trivial_orbit(generators: [Permutation]) -> int:
    """
    Returns an element with a nontrivial orbit in the group
    generated by <generators>, or <None> if no such element exists.
    (Useful for order computation / membership testing.)

    :param generators: list of permutations (from permv2.py), represent a generating set of a permutation group H
    :return: an element 'element' with a nontrivial orbit in the group
    generated by 'generators' or None if no such element exists
    """
    if len(generators) == 0:
        return None
    n = generators[0].n
    for P in generators:
        for element in range(n):
            if P[element] != element:
                return element


def reduce(generators: [Permutation], wordy=0) -> [Permutation]:
    """
    Given a generating list <generators> that
    generates a group H, this function returns a possibly smaller generating set for the
    same group H (but certainly not larger).
    The resulting generating set will contain less than n^2
    permutations, when the permutations are on n elements.
    (Set <wordy> =1 or 2 to see what is going on exactly.)

    :param generators: list of permutations (from permv2.py), represent a generating set of a permutation group H
    :param wordy:
    :return: generating set of H, list of generators
    """

    if wordy >= 1:
        print("  Reducing. Input length:", len(generators))
    if len(generators) == 0:
        return generators
    n = generators[0].n
    output_generators = []
    todo = generators
    while todo != []:
        element = find_non_trivial_orbit(todo)
        if element is None:  # can happen if the input (erroneously) contains trivial permutations
            break
        if wordy >= 2:
            print("    Next iteration: still to reduce:\n     ", todo)
            print("    Reducing for element", element)
        images = [None] * n
        todonext = []
        for P in todo:
            if P[element] == element:
                todonext.append(P)
            elif images[P[element]] is None:
                if wordy >= 2:
                    print("      Keeping", P, "which maps", element, "to", P[element])
                output_generators.append(P)
                images[P[element]] = P
            else:
                Q = -images[P[element]] * P
                if wordy >= 2:
                    print("      Changing", P, "to", Q)
                if not Q.istrivial():
                    todonext.append(Q)
        todo = todonext
    if wordy >= 1:
        print("  Output length:", len(output_generators))
    return output_generators


def stabilizer(generators: [Permutation], element: int) -> [Permutation]:
    """
    This function returns a generating set for H_{el}, the stabilizer subgroup of H
    for element <el>. The generating set has size less than n^2.

    :param generators: generating set for a group H
    :param element: an element from 0...n-1
    :return: stabilizer subgroup of H
    """
    return reduce(schreier_generators(generators, element), 0)


def member_of(f: Permutation, H: [Permutation]) -> bool:
    # Base case: trivial permutation
    if f.istrivial():
        return True

    # Pick an element with an orbit of at least length 2
    # Note that is always such an alpha, cause otherwise f is trivial
    alpha = find_non_trivial_orbit(H)
    orbit, transversal = compute_orbit(H, alpha, return_transversal=True)

    # Compute f(alpha), image of alpha under f
    beta = f.P[alpha]
    if beta not in orbit:
        return False
    else:
        # Compute generating set for ??
        stab_alpha = stabilizer(H, alpha)

        # For every index i, U[i] is a permutation from H that maps alpha to orbit[i].
        # Note: len(transversal) == len(orbit)
        # We want u_beta st. u_beta[alpha] = beta, eg. i st. orbit[i]=beta
        u = transversal[orbit.index(beta)]

        # Compute u_beta^-1 (transversal[i] is a permutation from H that maps 'alpha' to orbit[i])
        u_inverse = u.__neg__()

        # Compute u_beta^-1 * f
        perm = u_inverse.__mul__(f)

        # Check membership of u_beta^-1 * f in stabilizer of alpha
        return member_of(perm, stab_alpha)
